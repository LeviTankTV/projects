import { WaveManager } from './waveManager.js';
import { Player } from './player.js';
import { Camera } from './camera.js';
 import { Drop } from "./Drop.js";

export class LocalGameManager {
    constructor(canvas, playerName, theme) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.playerName = playerName;
        this.theme = theme;

        // World configuration
        this.worldWidth = 12000;
        this.worldHeight = 12000;

        // Create arena in the center of the world
        this.arena = this.createArena();

        // Create player at arena center
        this.player = this.createPlayer();

        // Create camera with world dimensions
        this.camera = new Camera(
            canvas,
            this.worldWidth,
            this.worldHeight
        );

        // Initialize Wave Manager
        this.waveManager = new WaveManager(this.arena, this.theme, this.ctx, this.player);

        this.isGameRunning = true;

        // Time tracking for consistent movement
        this.lastFrameTime = 0;
        this.targetFPS = 60;
        this.frameTime = 1000 / this.targetFPS;

        this.minZoom = 0.5;   // Minimum zoom level
        this.maxZoom = 2.0;   // Maximum zoom level
        this.zoomSensitivity = 0.1;  // Zoom speed

        // Add mouse wheel event listener
        this.setupZoomControls(canvas);

        // Generate initial wave of mobs
        this.waveManager.generateMobs();
        this.drops = [];
    }

     spawnDrop(dropConfig) {
        console.log('Spawning drop in LocalGameManager:', dropConfig);
        const drop = new Drop(
            dropConfig.x,
            dropConfig.y,
            dropConfig.type,
            dropConfig.rarity,
            dropConfig.imagePath
        );

        // Add additional logging
        console.log('Drop created:', drop);

        this.drops.push(drop);
    }

    // Update and draw drops method
     updateAndDrawDrops() {
         // Update drops
         this.drops.forEach(drop => {
             // Ensure draw method receives camera context
             drop.draw(this.ctx, this.camera);
         });

         // Remove collected or expired drops
         this.drops = this.drops.filter(drop => !drop.collected);
     }


    setupZoomControls(canvas) {
        canvas.addEventListener('wheel', (event) => {
            event.preventDefault();

            // Determine zoom direction
            const zoomDelta = event.deltaY > 0 ? -1 : 1;

            // Calculate new zoom level
            const newZoom = this.clamp(
                this.camera.zoom + (zoomDelta * this.zoomSensitivity),
                this.minZoom,
                this.maxZoom
            );

            // Update camera zoom
            this.camera.setZoom(newZoom);
        }, {passive: false});
    }


    // Utility method to clamp value between min and max
    clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
    }

    drawZoomIndicator() {
        const zoomPercentage = Math.round(this.camera.zoom * 100);

        this.ctx.save();
        this.ctx.resetTransform(); // Ensure drawing is not affected by camera transform

        // Draw zoom level text
        this.ctx.fillStyle = 'white';
        this.ctx.font = '16px Arial';
        this.ctx.fillText(`Zoom: ${zoomPercentage}%`, 10, 30);

        this.ctx.restore();
    }

    createArena() {
        return {
            x: this.worldWidth / 2,
            y: this.worldHeight / 2,
            radius: 500, // Starting radius of 500 (1000/2)
            color: this.getArenaColor(),
            width: this.worldWidth,
            height: this.worldHeight,
            baseRadius: 500,  // Store base radius for wave progression
            radiusIncrement: 25  // Half of 50x50
        };
    }

    nextWave() {
        // Increase arena radius
        this.arena.radius = this.arena.baseRadius +
            (this.waveManager.currentWave * this.arena.radiusIncrement);

        // Proceed to next wave
        this.waveManager.nextWave();
    }

    getArenaColor() {
        const themeColors = {
            'garden': 'rgba(34, 139, 34, 0.2)',
            'desert': 'rgba(238, 214, 175, 0.2)',
            'ocean': 'rgba(64, 164, 223, 0.2)'
        };
        return themeColors[this.theme.toLowerCase()] || themeColors['garden'];
    }

    createPlayer() {
        return new Player(
            this.arena.x,
            this.arena.y,
            this.arena,
            {
                name: this.playerName || 'Player'
            }
        );
    }

    updatePlayer(deltaTime) {
        // Normalize movement speed based on delta time
        // This ensures consistent movement across different frame rates
        const speedMultiplier = deltaTime / this.frameTime;

        // Temporarily modify player's base speed for this frame
        const originalSpeed = this.player.baseSpeed;
        this.player.baseSpeed *= speedMultiplier;

        const keyState = this.player.movement.keys;
        // Update player movement
        this.player.update(deltaTime, keyState);

        // Restore original speed
        this.player.baseSpeed = originalSpeed;
    }

    checkPetalMobCollisions() {
        this.player.selectedPetals.forEach(petal => {
            // Only check collision if petal is not recharging
            if (!petal.isRecharging) {
                this.waveManager.mobs.forEach(mob => {
                    if (petal.checkCollisionWithMob(mob)) {
                        // Petal hits mob
                        const petalRecharging = petal.dealDamageToMob(mob);

                        if (mob.health <= 0) {
                            // Mob dies
                            mob.die();
                            this.player.addScore(10);
                            this.player.addKill();
                        }

                        // Note: No removal, just recharging
                    }
                });
            }
        });
    }

    gameLoop(currentTime = 0) {
        // Ð Ð°Ð½Ð½Ð¸Ð¹ Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‚ Ð´Ð»Ñ Ð¿Ñ€ÐµÐ´Ð¾Ñ‚Ð²Ñ€Ð°Ñ‰ÐµÐ½Ð¸Ñ Ð»Ð¸ÑˆÐ½Ð¸Ñ… Ð²Ñ‹Ñ‡Ð¸ÑÐ»ÐµÐ½Ð¸Ð¹
        if (!this.isGameRunning) return;

        // ÐžÐ¿Ñ‚Ð¸Ð¼Ð¸Ð·Ð°Ñ†Ð¸Ñ Ñ€Ð°ÑÑ‡ÐµÑ‚Ð° Ð²Ñ€ÐµÐ¼ÐµÐ½Ð¸
        const deltaTime = currentTime - (this.lastFrameTime || currentTime);
        this.lastFrameTime = currentTime;

        // ÐŸÐ°ÐºÐµÑ‚Ð½Ð°Ñ Ð¾Ð¿Ñ‚Ð¸Ð¼Ð¸Ð·Ð°Ñ†Ð¸Ñ Ð¾Ñ‚Ñ€Ð¸ÑÐ¾Ð²ÐºÐ¸ Ð¸ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ð¹
        const performUpdate = () => {
            // ÐœÐ¸Ð½Ð¸Ð¼Ð¸Ð·Ð°Ñ†Ð¸Ñ Ð¾Ñ‡Ð¸ÑÑ‚ÐºÐ¸ canvas
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

            // ÐšÑÑˆÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ Ñ‡Ð°ÑÑ‚Ð¾ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼Ñ‹Ñ… Ð¾Ð±ÑŠÐµÐºÑ‚Ð¾Ð²
            const { player, camera, waveManager } = this;

            // ÐžÐ¿Ñ‚Ð¸Ð¼Ð¸Ð·Ð°Ñ†Ð¸Ñ ÐºÐ°Ð¼ÐµÑ€Ñ‹ - Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÑÑ‚ÑŒ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð¿Ñ€Ð¸ Ð½ÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ð¾ÑÑ‚Ð¸
            camera.follow(player);
            camera.begin();

            // ÐžÐ±ÑŠÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ðµ Ð¾Ñ‚Ñ€Ð¸ÑÐ¾Ð²ÐºÐ¸ Ñ„Ð¾Ð½Ð°
            this.drawWorldBackground();
            this.drawArena();

            // ÐžÐ¿Ñ‚Ð¸Ð¼Ð¸Ð·Ð°Ñ†Ð¸Ñ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ð¹ - Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ Ð¿Ð°ÐºÐµÑ‚Ð½ÑƒÑŽ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÑƒ
            player.update(deltaTime);
            waveManager.update(player);

            // ÐžÐ¿Ñ‚Ð¸Ð¼Ð¸Ð·Ð°Ñ†Ð¸Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸ ÑÑ‚Ð¾Ð»ÐºÐ½Ð¾Ð²ÐµÐ½Ð¸Ð¹
            this.checkCollisions();

            // ÐžÐ¿Ñ‚Ð¸Ð¼Ð¸Ð·Ð°Ñ†Ð¸Ñ ÑÐ¿Ð°Ð²Ð½Ð° Ð´Ñ€Ð¾Ð¿Ð¾Ð²
            this.handleDropSpawning();

            // ÐžÑ‚Ñ€Ð¸ÑÐ¾Ð²ÐºÐ° Ð¾Ð±ÑŠÐµÐºÑ‚Ð¾Ð²
            this.renderGameObjects();

            camera.end();

            // ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° Ð²Ð¾Ð»Ð½Ñ‹ Ñ Ð¼Ð¸Ð½Ð¸Ð¼Ð°Ð»ÑŒÐ½Ñ‹Ð¼Ð¸ Ð½Ð°ÐºÐ»Ð°Ð´Ð½Ñ‹Ð¼Ð¸ Ñ€Ð°ÑÑ…Ð¾Ð´Ð°Ð¼Ð¸
            this.checkWaveCompletion();
        };

        // ÐžÐ¿Ñ‚Ð¸Ð¼Ð¸Ð·Ð°Ñ†Ð¸Ñ UI - Ð²Ñ‹Ð½Ð¾ÑÐ¸Ð¼ Ð·Ð° Ð¿Ñ€ÐµÐ´ÐµÐ»Ñ‹ Ð¾ÑÐ½Ð¾Ð²Ð½Ð¾Ð³Ð¾ Ñ€ÐµÐ½Ð´ÐµÑ€Ð¸Ð½Ð³Ð°
        const renderUI = () => {
            this.drawZoomIndicator();
            this.player.hotbar.draw(this.ctx, this.canvas.width, this.canvas.height);
            this.player.inventory.drawIcon(this.ctx);
            this.player.inventory.drawInventoryView(
                this.ctx,
                this.canvas.width,
                this.canvas.height
            );
        };

        // Ð’Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ðµ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ð¹ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð¿Ñ€Ð¸ Ð½Ð°Ð»Ð¸Ñ‡Ð¸Ð¸ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð¸
        if (deltaTime > 0) {
            performUpdate();
        }

        renderUI();

        // ÐžÐ¿Ñ‚Ð¸Ð¼Ð¸Ð·Ð°Ñ†Ð¸Ñ game loop - Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ ÑÐ²ÑÐ·Ñ‹Ð²Ð°Ð½Ð¸Ðµ Ð¾Ð´Ð¸Ð½ Ñ€Ð°Ð·
        this.animationFrameId = requestAnimationFrame(this.gameLoop.bind(this));
    }
    
    updateGameState(deltaTime) {
        this.player.update(deltaTime);
        this.waveManager.update(this.player);
    }

    renderGameObjects() {
        this.camera.begin();

        this.drawWorldBackground();
        this.player.draw(this.ctx);
        this.waveManager.draw(this.ctx);

        this.camera.end();
    }

    checkGameConditions() {
        if (this.waveManager.isWaveCleared()) {
            this.nextWave();
        }

        this.checkCollisions();
    }

    checkCollisions() {
        // ÐžÐ¿Ñ‚Ð¸Ð¼Ð¸Ð·Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ðµ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸ ÑÑ‚Ð¾Ð»ÐºÐ½Ð¾Ð²ÐµÐ½Ð¸Ð¹
        this.checkPetalMobCollisions();
        this.checkMobCollisions();
    }

// ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° ÐºÑ€Ð¸Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸Ñ… Ð¾ÑˆÐ¸Ð±Ð¾Ðº
    handleGameLoopError(error) {
        console.group('%cðŸ”¥ Game Loop Critical Error', 'color: red; font-weight: bold');
        console.error('Error Details:', error);

        // Ð Ð°ÑÑˆÐ¸Ñ€ÐµÐ½Ð½Ð°Ñ Ð´Ð¸Ð°Ð³Ð½Ð¾ÑÑ‚Ð¸ÐºÐ° ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ñ Ð¸Ð³Ñ€Ñ‹
        console.log('Game State:', {
            isRunning: this.isGameRunning,
            playerHealth: this.player?.health,
            currentWave: this.waveManager?.currentWave,
            mobCount: this.waveManager?.mobs?.length
        });

        console.groupEnd();

        // Ð”Ð¸ÑÐ¿ÐµÑ‚Ñ‡ÐµÑ€Ð¸Ð·Ð°Ñ†Ð¸Ñ ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ñ Ð·Ð°Ð²ÐµÑ€ÑˆÐµÐ½Ð¸Ñ Ð¸Ð³Ñ€Ñ‹
        const gameOverEvent = new CustomEvent('gameOver', {
            detail: {
                reason: 'game_loop_failure',
                error: error.message
            }
        });
        document.dispatchEvent(gameOverEvent);
    }

    // Optional: Method to handle player-mob interactions
    checkMobCollisions() {
        this.waveManager.mobs.forEach(mob => {
            const distance = Math.hypot(
                this.player.x - mob.x,
                this.player.y - mob.y
            );

            const collisionThreshold = this.player.radius + mob.size;

            if (distance < collisionThreshold) {
                // Mob rams player
                mob.bodyAttack(this.player);

                // Aggravate mob on collision
                if (!mob.isAggravated) {
                    mob.isAggravated = true;
                    mob.aggressionTimer = Date.now();
                }
            }
        });
    }

    handlePlayerMobCollision(mob) {
        // Implement collision logic
        // For example:
        // - Reduce player health
        // - Apply knockback
        // - Mark mob as hit/dead
        mob.takeDamage(this.player.damage);
    }

    // Optional: Add wave-related UI or game state methods
    getCurrentWave() {
        return this.waveManager.currentWave;
    }

    getRemainingMobs() {
        return this.waveManager.mobs.length;
    }

    start() {
        // Reset game state if needed
        this.waveManager.generateMobs();
        this.gameLoop();
    }

    end() {
        this.isGameRunning = false;
        // Additional cleanup if needed
    }

    drawWorldBackground() {
        // Light grid or texture for world background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
        this.ctx.fillRect(0, 0, this.worldWidth, this.worldHeight);

        // Optional: Draw grid lines
        this.ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        this.ctx.lineWidth = 1;

        // Vertical lines
        for (let x = 0; x < this.worldWidth; x += 100) {
            this.ctx.beginPath();
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(x, this.worldHeight);
            this.ctx.stroke();
        }

        // Horizontal lines
        for (let y = 0; y < this.worldHeight; y += 100) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.worldWidth, y);
            this.ctx.stroke();
        }
    }

    drawArena() {
        this.ctx.beginPath();
        this.ctx.arc(
            this.arena.x,
            this.arena.y,
            this.arena.radius,
            0,
            Math.PI * 2
        );
        this.ctx.fillStyle = this.arena.color;
        this.ctx.fill();

        // Arena border
        this.ctx.strokeStyle = 'rgba(255,255,255,0.5)';
        this.ctx.lineWidth = 2;
        this.ctx.stroke();
    }

    start() {
        this.gameLoop();
    }


    end() {
        this.isGameRunning = false;
    }
}
class QuadTree {
    constructor(boundary, capacity = 4) {
        this.boundary = boundary;
        this.capacity = capacity;
        this.objects = [];
        this.divided = false;
        this.northwest = null;
        this.northeast = null;
        this.southwest = null;
        this.southeast = null;
    }

    insert(gameObject) {
        if (!this.boundary.contains(gameObject)) return false;

        if (this.objects.length < this.capacity) {
            this.objects.push(gameObject);
            return true;
        }

        if (!this.divided) this.subdivide();

        return (
            this.northwest.insert(gameObject) ||
            this.northeast.insert(gameObject) ||
            this.southwest.insert(gameObject) ||
            this.southeast.insert(gameObject)
        );
    }

    subdivide() {
        // Ð›Ð¾Ð³Ð¸ÐºÐ° Ñ€Ð°Ð·Ð´ÐµÐ»ÐµÐ½Ð¸Ñ ÐºÐ²Ð°Ð´Ñ€Ð°Ð½Ñ‚Ð°
    }
}
